<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>三角形内角和的证明 - 互动实验</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            color: #333;
            min-height: 100vh;
            padding: 20px;
            transition: background-image 0.5s ease;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            padding: 30px;
            position: relative;
            overflow: hidden;
        }
        
        .decoration {
            position: absolute;
            z-index: 0;
        }
        
        .decoration-1 {
            width: 150px;
            height: 150px;
            background: rgba(255, 107, 107, 0.1);
            border-radius: 50%;
            top: -50px;
            right: -50px;
        }
        
        .decoration-2 {
            width: 100px;
            height: 100px;
            background: rgba(77, 171, 247, 0.1);
            border-radius: 50%;
            bottom: -30px;
            left: -30px;
        }
        
        .decoration-3 {
            width: 80px;
            height: 80px;
            background: rgba(120, 224, 143, 0.1);
            border-radius: 50%;
            top: 50%;
            left: -20px;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            position: relative;
            z-index: 1;
        }
        
        h1 {
            color: #2c3e50;
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .subtitle {
            color: #7f8c8d;
            font-size: 1.2rem;
            margin-bottom: 20px;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 12px 25px;
            border: none;
            border-radius: 50px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        #import-bg {
            background: linear-gradient(45deg, #6a89cc, #4a69bd);
            color: white;
        }
        
        #reset {
            background: linear-gradient(45deg, #f78fb3, #f8a5c2);
            color: white;
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }
        
        button:active {
            transform: translateY(1px);
        }
        
        .experiment-container {
            display: flex;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .experiment-area {
            position: relative;
            width: 70%;
            height: 500px;
            background-color: rgba(255, 255, 255, 0.7);
            border-radius: 10px;
            overflow: hidden;
            border: 2px dashed #bdc3c7;
        }
        
        .controls-panel {
            width: 30%;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        #triangle-canvas {
            width: 100%;
            height: 100%;
        }
        
        .parallel-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .parallel-btn {
            padding: 12px 20px;
            border-radius: 30px;
            font-size: 1rem;
            border: 2px solid;
            text-align: center;
        }
        
        #toggle-ab {
            border-color: #e74c3c;
            background-color: rgba(231, 76, 60, 0.1);
            color: #e74c3c;
        }
        
        #toggle-bc {
            border-color: #2ecc71;
            background-color: rgba(46, 204, 113, 0.1);
            color: #2ecc71;
        }
        
        #toggle-ac {
            border-color: #f39c12;
            background-color: rgba(243, 156, 18, 0.1);
            color: #f39c12;
        }
        
        .slider-container {
            margin-bottom: 15px;
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2c3e50;
        }
        
        .slider {
            width: 100%;
            height: 10px;
            -webkit-appearance: none;
            appearance: none;
            background: #ecf0f1;
            outline: none;
            border-radius: 5px;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            cursor: pointer;
        }
        
        #slider-ab::-webkit-slider-thumb {
            background: #e74c3c;
        }
        
        #slider-bc::-webkit-slider-thumb {
            background: #2ecc71;
        }
        
        #slider-ac::-webkit-slider-thumb {
            background: #f39c12;
        }
        
        .slider-value {
            font-weight: normal;
            color: #7f8c8d;
        }
        
        .proof-text {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
            border-left: 5px solid #3498db;
        }
        
        .proof-text h3 {
            color: #3498db;
            margin-bottom: 10px;
        }
        
        .proof-text p {
            line-height: 1.6;
            margin-bottom: 10px;
        }
        
        footer {
            text-align: center;
            margin-top: 30px;
            color: #7f8c8d;
            font-size: 0.9rem;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .experiment-container {
                flex-direction: column;
            }
            
            .experiment-area, .controls-panel {
                width: 100%;
            }
            
            .experiment-area {
                height: 300px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="decoration decoration-1"></div>
        <div class="decoration decoration-2"></div>
        <div class="decoration decoration-3"></div>
        
        <header>
            <h1>三角形内角和的证明</h1>
            <p class="subtitle">通过平行线性质探索三角形内角和为180°的原理</p>
        </header>
        
        <div class="controls">
            <button id="import-bg">导入背景图</button>
            <button id="reset">重置实验</button>
        </div>
        
        <div class="experiment-container">
            <div class="controls-panel">
                <div class="parallel-controls">
                    <button class="parallel-btn" id="toggle-ab">显示/隐藏 AB 边平行线</button>
                    <button class="parallel-btn" id="toggle-bc">显示/隐藏 BC 边平行线</button>
                    <button class="parallel-btn" id="toggle-ac">显示/隐藏 AC 边平行线</button>
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>AB 边平行线位置</span>
                        <span id="ab-value" class="slider-value">0px</span>
                    </div>
                    <input type="range" min="-500" max="500" value="0" class="slider" id="slider-ab">
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>BC 边平行线位置</span>
                        <span id="bc-value" class="slider-value">0px</span>
                    </div>
                    <input type="range" min="-500" max="500" value="0" class="slider" id="slider-bc">
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>AC 边平行线位置</span>
                        <span id="ac-value" class="slider-value">0px</span>
                    </div>
                    <input type="range" min="-500" max="500" value="0" class="slider" id="slider-ac">
                </div>
            </div>
            
            <div class="experiment-area">
                <canvas id="triangle-canvas"></canvas>
            </div>
        </div>
        
        <div class="proof-text">
            <h3>证明原理</h3>
            <p>通过绘制与三角形各边平行的直线，我们可以利用平行线的性质证明三角形内角和为180°。</p>
            <p>1. 平行线A1B1与AB平行，根据平行线性质，∠A = ∠A1</p>
            <p>2. 平行线B1C1与BC平行，根据平行线性质，∠B = ∠B1</p>
            <p>3. 平行线A1C1与AC平行，根据平行线性质，∠C = ∠C1</p>
            <p>由于A1B1、B1C1和A1C1三条直线在平面上相交，形成的角度总和为180°，因此三角形ABC的内角和也为180°。</p>
            <p><strong>提示：</strong> 现在平行线的移动范围已大幅增加（-500px到500px），您可以更灵活地观察平行线与三角形的关系。</p>
        </div>
        
        <footer>
            <p>三角形内角和证明互动实验 © 2023</p>
        </footer>
    </div>

    <script>
        // 获取Canvas元素和上下文
        const canvas = document.getElementById('triangle-canvas');
        const ctx = canvas.getContext('2d');
        
        // 设置Canvas尺寸
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            drawScene();
        }
        
        // 初始化变量
        let backgroundImage = null;
        let showABParallel = false;
        let showBCParallel = false;
        let showACParallel = false;
        let abOffset = 0;  // 使用像素偏移值而不是百分比
        let bcOffset = 0;
        let acOffset = 0;
        
        // 三角形顶点坐标（相对坐标，基于Canvas尺寸）
        const triangle = {
            A: { x: 0.3, y: 0.6 },
            B: { x: 0.7, y: 0.6 },
            C: { x: 0.5, y: 0.2 }
        };
        
        // 绘制场景
        function drawScene() {
            const width = canvas.width;
            const height = canvas.height;
            
            // 清除画布
            ctx.clearRect(0, 0, width, height);
            
            // 绘制背景图（如果有）
            if (backgroundImage) {
                ctx.drawImage(backgroundImage, 0, 0, width, height);
            }
            
            // 计算实际坐标
            const A = { x: triangle.A.x * width, y: triangle.A.y * height };
            const B = { x: triangle.B.x * width, y: triangle.B.y * height };
            const C = { x: triangle.C.x * width, y: triangle.C.y * height };
            
            // 绘制三角形
            ctx.beginPath();
            ctx.moveTo(A.x, A.y);
            ctx.lineTo(B.x, B.y);
            ctx.lineTo(C.x, C.y);
            ctx.closePath();
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.fill();
            ctx.lineWidth = 3;
            ctx.strokeStyle = '#2c3e50';
            ctx.stroke();
            
            // 绘制三角形边（不同颜色）
            drawLine(A, B, '#e74c3c', 4); // AB边 - 红色
            drawLine(B, C, '#2ecc71', 4); // BC边 - 绿色
            drawLine(C, A, '#f39c12', 4); // AC边 - 橙色
            
            // 绘制顶点标签
            drawLabel('A', A.x - 15, A.y + 20);
            drawLabel('B', B.x + 10, B.y + 20);
            drawLabel('C', C.x, C.y - 15);
            
            // 绘制平行线（如果显示）- 延长版本，使用更大的偏移范围
            if (showABParallel) {
                drawExtendedParallelLine(A, B, abOffset, '#e74c3c');
                // 在AB平行线上添加两个动点A1和B1
                drawMovingPointsOnLine(A, B, abOffset, 'A1', 'B1', '#e74c3c');
            }
            
            if (showBCParallel) {
                drawExtendedParallelLine(B, C, bcOffset, '#2ecc71');
                // 在BC平行线上添加两个动点B1和C1
                drawMovingPointsOnLine(B, C, bcOffset, 'B1', 'C1', '#2ecc71');
            }
            
            if (showACParallel) {
                drawExtendedParallelLine(C, A, acOffset, '#f39c12');
                // 在AC平行线上添加两个动点A1和C1
                drawMovingPointsOnLine(C, A, acOffset, 'A1', 'C1', '#f39c12');
            }
            
            // 绘制角度标记（不显示任何角的度数）
            drawAngleMarkers(A, B, C);
        }
        
        // 绘制直线
        function drawLine(start, end, color, width) {
            ctx.beginPath();
            ctx.moveTo(start.x, start.y);
            ctx.lineTo(end.x, end.y);
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.stroke();
        }
        
        // 绘制标签
        function drawLabel(text, x, y) {
            ctx.fillStyle = '#2c3e50';
            ctx.font = 'bold 16px Arial';
            ctx.fillText(text, x, y);
        }
        
        // 绘制延长平行线（使用更大的偏移范围）
        function drawExtendedParallelLine(point1, point2, offset, color) {
            // 计算边的向量
            const dx = point2.x - point1.x;
            const dy = point2.y - point1.y;
            
            // 计算边的长度
            const length = Math.sqrt(dx * dx + dy * dy);
            
            // 计算垂直向量（用于偏移）- 使用更大的偏移范围
            const perpendicular = {
                x: -dy / length * offset,
                y: dx / length * offset
            };
            
            // 计算平行线的起点和终点（大幅延长版本）
            const extensionFactor = 5; // 大幅增加延长因子
            const start = {
                x: point1.x + perpendicular.x - dx * extensionFactor,
                y: point1.y + perpendicular.y - dy * extensionFactor
            };
            
            const end = {
                x: point2.x + perpendicular.x + dx * extensionFactor,
                y: point2.y + perpendicular.y + dy * extensionFactor
            };
            
            // 绘制平行线（虚线）
            ctx.beginPath();
            ctx.moveTo(start.x, start.y);
            ctx.lineTo(end.x, end.y);
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        // 在平行线上绘制动点
        function drawMovingPointsOnLine(point1, point2, offset, label1, label2, color) {
            // 计算边的向量
            const dx = point2.x - point1.x;
            const dy = point2.y - point1.y;
            
            // 计算边的长度
            const length = Math.sqrt(dx * dx + dy * dy);
            
            // 计算垂直向量（用于偏移）
            const perpendicular = {
                x: -dy / length * offset,
                y: dx / length * offset
            };
            
            // 计算平行线的起点和终点（大幅延长版本）
            const extensionFactor = 5;
            const start = {
                x: point1.x + perpendicular.x - dx * extensionFactor,
                y: point1.y + perpendicular.y - dy * extensionFactor
            };
            
            const end = {
                x: point2.x + perpendicular.x + dx * extensionFactor,
                y: point2.y + perpendicular.y + dy * extensionFactor
            };
            
            // 计算动点位置（在平行线的1/3和2/3处）
            const point1Pos = {
                x: start.x + (end.x - start.x) * 0.3,
                y: start.y + (end.y - start.y) * 0.3
            };
            
            const point2Pos = {
                x: start.x + (end.x - start.x) * 0.7,
                y: start.y + (end.y - start.y) * 0.7
            };
            
            // 绘制动点1
            ctx.beginPath();
            ctx.arc(point1Pos.x, point1Pos.y, 6, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 1;
            ctx.stroke();
            
            // 绘制动点1标签
            ctx.fillStyle = '#2c3e50';
            ctx.font = 'bold 14px Arial';
            ctx.fillText(label1, point1Pos.x + 8, point1Pos.y + 5);
            
            // 绘制动点2
            ctx.beginPath();
            ctx.arc(point2Pos.x, point2Pos.y, 6, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 1;
            ctx.stroke();
            
            // 绘制动点2标签
            ctx.fillStyle = '#2c3e50';
            ctx.font = 'bold 14px Arial';
            ctx.fillText(label2, point2Pos.x + 8, point2Pos.y + 5);
        }
        
        // 绘制角度标记（不显示任何角的度数）
        function drawAngleMarkers(A, B, C) {
            // 在顶点A处绘制角度标记（不显示度数）
            drawAngleArc(A, B, C, 20, '#e74c3c');
            
            // 在顶点B处绘制角度标记（不显示度数）
            drawAngleArc(B, A, C, 20, '#2ecc71');
            
            // 在顶点C处绘制角度标记（不显示度数）
            drawAngleArc(C, A, B, 20, '#f39c12');
        }
        
        // 绘制角度弧线
        function drawAngleArc(vertex, point1, point2, radius, color) {
            // 计算两个向量
            const v1 = { x: point1.x - vertex.x, y: point1.y - vertex.y };
            const v2 = { x: point2.x - vertex.x, y: point2.y - vertex.y };
            
            // 计算向量的角度
            const angle1 = Math.atan2(v1.y, v1.x);
            const angle2 = Math.atan2(v2.y, v2.x);
            
            // 确定起始角度和结束角度
            let startAngle = Math.min(angle1, angle2);
            let endAngle = Math.max(angle1, angle2);
            
            // 如果角度差大于π，则调整
            if (endAngle - startAngle > Math.PI) {
                [startAngle, endAngle] = [endAngle, startAngle + 2 * Math.PI];
            }
            
            // 绘制弧线
            ctx.beginPath();
            ctx.arc(vertex.x, vertex.y, radius, startAngle, endAngle);
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        
        // 事件监听器
        document.getElementById('import-bg').addEventListener('click', function() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        backgroundImage = new Image();
                        backgroundImage.onload = function() {
                            drawScene();
                        };
                        backgroundImage.src = event.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            };
            input.click();
        });
        
        document.getElementById('reset').addEventListener('click', function() {
            backgroundImage = null;
            showABParallel = false;
            showBCParallel = false;
            showACParallel = false;
            abOffset = 0;
            bcOffset = 0;
            acOffset = 0;
            
            document.getElementById('slider-ab').value = 0;
            document.getElementById('slider-bc').value = 0;
            document.getElementById('slider-ac').value = 0;
            
            document.getElementById('ab-value').textContent = '0px';
            document.getElementById('bc-value').textContent = '0px';
            document.getElementById('ac-value').textContent = '0px';
            
            drawScene();
        });
        
        document.getElementById('toggle-ab').addEventListener('click', function() {
            showABParallel = !showABParallel;
            drawScene();
        });
        
        document.getElementById('toggle-bc').addEventListener('click', function() {
            showBCParallel = !showBCParallel;
            drawScene();
        });
        
        document.getElementById('toggle-ac').addEventListener('click', function() {
            showACParallel = !showACParallel;
            drawScene();
        });
        
        document.getElementById('slider-ab').addEventListener('input', function(e) {
            abOffset = parseInt(e.target.value);
            document.getElementById('ab-value').textContent = abOffset + 'px';
            drawScene();
        });
        
        document.getElementById('slider-bc').addEventListener('input', function(e) {
            bcOffset = parseInt(e.target.value);
            document.getElementById('bc-value').textContent = bcOffset + 'px';
            drawScene();
        });
        
        document.getElementById('slider-ac').addEventListener('input', function(e) {
            acOffset = parseInt(e.target.value);
            document.getElementById('ac-value').textContent = acOffset + 'px';
            drawScene();
        });
        
        // 初始化和调整窗口大小时重绘
        window.addEventListener('load', resizeCanvas);
        window.addEventListener('resize', resizeCanvas);
    </script>
</body>
</html>